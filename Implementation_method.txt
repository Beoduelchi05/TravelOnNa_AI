## 1. 기록(피드) 추천: SNS 스타일

> **시나리오**:  
> 사용자가 올린 기록(사진, 글 등)을 SNS처럼 피드에서 볼 수 있고,  
> 좋아요 및 댓글 등의 상호작용이 발생한다.  
> 이때 “사용자와 유사한 기록”이나 “사용자가 상호작용한 유형의 기록”을 추천하고 싶다.

### (1) 어떤 테이블을 어떻게 활용할까?

1. **log**(기록 테이블, 혹은 다른 이름)  
   - 사용자가 작성한 여행 기록의 본문, 작성자, 작성 시각 등을 보유.  
   - 우리의 “아이템”이 될 수 있음(추천 대상).

2. **user_actions**  
   - 사용자가 어떤 기록에 좋아요, 댓글, 조회 등을 했는지 보유.  
   - 협업 필터링의 기본 데이터(사용자-아이템 상호작용)를 축적.

3. **user_similarities / item_similarities**  
   - “유사한 사용자”를 찾거나, “유사한 기록(log)”을 찾아내기 위한 유사도 정보.  
   - 예: user-based CF(사용자 유사도), item-based CF(기록 유사도).

4. **recommendations**  
   - 최종적으로 생성된 추천 기록 리스트를 캐싱(빠른 제공)하거나,  
   - 피드에 노출하기 전에 임시로 저장.

5. **feedback**  
   - 사용자가 추천된 기록(피드)을 보고 실제로 좋아요를 눌렀는지, 스크롤을 내렸는지, “싫어요”를 했는지 등을 기록해 모델 성능 개선.

### (2) 구현 개념 예시

1. **콘텐츠 기반 접근**  
   - **item_similarities** 테이블에 기록 간 유사도를 저장.  
   - 사용자가 이미 좋아요/댓글을 남긴 기록과 유사한 기록을 찾아서 추천.

2. **협업 필터링 접근**  
   - **user_actions**에서 “A 사용자가 X 기록에 좋아요” 같은 상호작용을 분석.  
   - **user_similarities**를 이용해 사용자끼리 “비슷한 취향”이면,  
     그 다른 사용자가 좋아한 기록을 현재 사용자에게도 추천.

3. **실시간 반응형 업데이트**  
   - 사용자가 좋아요를 누르거나, 기록을 클릭할 때마다 **user_actions**에 기록하고, 이를 기반으로 유사도 계산을 업데이트(또는 배치/주기적).  
   - 최신 기록도 상호작용 데이터가 쌓이면 점차 추천 후보로 올라옴.

> **결과**: 인스타그램 피드처럼, 사용자가 좋아할 만한 기록(또는 유사 사용자들이 본 기록)을 상단에 노출.


---

## 2. 여행 일정(계획) 추천

> **시나리오**:  
> 사용자가 여행 일정을 새로 만들 때,  
> - 사용자의 **과거 일정**(방문 도시, 숙박 패턴, 여행 스타일)을 분석  
> - 당시 **계절**(봄, 여름 등) 또는 다른 사용자들의 **여행 경향**(인기 여행지)을 참조  
> - 개인 맞춤형 여행지, 여행 장소를 자동 추천

### (1) 어떤 테이블을 어떻게 활용할까?

1. **plan**(여행 일정) / **place**(일정 속 방문 장소)  
   - 사용자별로 과거에 작성한 여행 일정과 방문 장소를 확인할 수 있음(“사용자의 과거 취향”).

2. **user_actions**  
   - 일정이나 장소(아이템화 가능)와의 상호작용이 기록된다면, 예: 일정에 좋아요, 북마크, 공유 등.

3. **user_preferences**  
   - 사용자가 선호하는 **여행 카테고리**(예: 맛집 탐방, 액티비티, 휴양 등),  
   - **계절**(봄, 여름에 주로 여행), **여행 스타일**(혼행, 가족여행 등)을 기록.

4. **item_similarities**  
   - 여행지/장소 간의 유사도 정보. (예: 둘 다 해안가 휴양지, 둘 다 온천이 유명 등)

5. **user_similarities**  
   - 비슷한 패턴의 일정을 자주 세우는 사용자들이 방문했던 여행지를 공유.

### (2) 구현 개념 예시

1. **사용자 과거 일정 분석**  
   - 과거 plan, place 테이블에서 사용자(user_id)의 방문 지역, 시기(start_date/end_date) 등을 수집.  
   - user_preferences를 업데이트(“봄에 자연 경관 여행지를 자주 간다” 등).

2. **계절/트렌드 반영**  
   - 현재 날짜 기준 계절(봄, 여름, 가을, 겨울)이나 특정 이벤트(예: 벚꽃 시즌) 정보를 매핑.  
   - 다른 사용자들이 최근에 자주 간 여행지도( user_actions + place )를 통계 내어 인기 순위를 산출.  
   - **추천 알고리즘**에서 계절 가중치, 인기 가중치 등을 결합.

3. **협업 필터링 + 콘텐츠 기반**  
   - 유사 사용자( user_similarities )가 “봄 시즌”에 갔던 여행지,  
   - 그리고 내가 “힐링” 스타일을 좋아한다면( user_preferences ),  
   - item_similarities를 통해 “비슷한 여행지”도 제안.

4. **최종 일정 추천**  
   - “계절, 인기 트렌드, 개인 취향”을 종합해 점수를 산출한 뒤, **recommendations** 테이블에 캐싱.  
   - 사용자가 일정 만들기를 시작할 때, 추천 여행지 리스트(또는 지도 마커)를 우선적으로 노출.

> **결과**: 사용자는 “자동 추천된 여행지”를 참고해 편리하게 일정을 작성,  
> 한편 시스템은 사용자 피드백(선택/취소, 후기 등)으로 모델을 지속 개선.


---

## 3. 결론: 기존 테이블로 가능할까?

위 두 가지 시나리오는, 우리가 설계한 **user_actions**, **user_preferences**, **user_similarities**, **item_similarities**, **recommendations**, **feedback** 등의 테이블을 통해 충분히 구현 가능합니다.

- **기록 추천**  
  - 아이템을 “기록(log)”로 보고, user_actions를 통해 사용자-기록 간 상호작용 데이터를 수집 → 협업 필터링 / 콘텐츠 기반 / 하이브리드

- **여행 일정(계획) 추천**  
  - 아이템을 “여행지(place)” 또는 “일정(plan)”으로 보고, user_preferences / user_similarities / item_similarities를 활용 → 계절, 트렌드, 개인 취향 결합

또한 **feedback**을 통해 “사용자가 실제로 추천된 일정(혹은 기록)을 받아들였는지”를 추적해 모델 성능을 계속 높일 수 있습니다.

결론적으로, **두 가지 추천 시스템 모두** 우리가 정의해 둔 **추천 관련 테이블**(협업 필터링 + 콘텐츠 기반을 포함한 하이브리드 구조)에 잘 들어맞습니다.